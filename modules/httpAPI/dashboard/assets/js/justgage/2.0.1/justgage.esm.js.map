{
  "version": 3,
  "sources": ["../src/utils/helpers.js", "../src/core/config.js", "../src/rendering/svg.js", "../src/utils/colors.js", "../src/utils/formatters.js", "../src/core/GaugeAnimator.js", "../src/core/JustGage.js", "package-json:../package.json", "../src/index.js"],
  "sourcesContent": ["/**\n * General utility functions for JustGage\n */\n\n/**\n * Check if a value is undefined or null\n * @param {any} v - Value to check\n * @returns {boolean} True if undefined or null\n */\nexport function isUndefined(v) {\n  return v === null || v === undefined;\n}\n\n/**\n * Check if a value is a valid number\n * @param {any} n - Value to check\n * @returns {boolean} True if valid number\n */\nexport function isNumber(n) {\n  return n !== null && n !== undefined && !isNaN(n);\n}\n\n/**\n * Extend target object with properties from source objects\n * @param {object} out - Target object\n * @param {...object} sources - Source objects\n * @returns {object} Extended object\n */\nexport function extend(out, ...sources) {\n  out = out || {};\n\n  for (const source of sources) {\n    if (!source) {\n      continue;\n    }\n\n    for (const key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        out[key] = source[key];\n      }\n    }\n  }\n\n  return out;\n}\n\n/**\n * Generate a UUID v4\n * @returns {string} UUID string\n */\nexport function uuid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\n/**\n * Lookup value from multiple hash tables with fallback\n * @param {string} key - Key to lookup\n * @param {object} tableA - First table\n * @param {object} tableB - Second table (e.g., dataset)\n * @param {any} defVal - Default value\n * @param {string} dataType - Data type conversion ('int', 'float')\n * @returns {any} Found value or default\n */\nexport function kvLookup(key, tableA, tableB, defVal, dataType) {\n  let val = defVal;\n  let canConvert = false;\n\n  if (!isUndefined(key)) {\n    if (!isUndefined(tableB) && typeof tableB === 'object' && key in tableB) {\n      val = tableB[key];\n      canConvert = true;\n    } else if (!isUndefined(tableA) && typeof tableA === 'object' && key in tableA) {\n      val = tableA[key];\n      canConvert = true;\n    } else {\n      val = defVal;\n    }\n\n    if (canConvert && !isUndefined(dataType)) {\n      switch (dataType) {\n        case 'int':\n          val = parseInt(val, 10);\n          break;\n        case 'float':\n          val = parseFloat(val);\n          break;\n        default:\n          break;\n      }\n    }\n  }\n\n  return val;\n}\n\n/**\n * Clamp a value between min and max\n * @param {number} value - Value to clamp\n * @param {number} min - Minimum value\n * @param {number} max - Maximum value\n * @returns {number} Clamped value\n */\nexport function clamp(value, min, max) {\n  return Math.min(Math.max(value, min), max);\n}\n\n/**\n * Create a simple event emitter\n * @returns {object} Event emitter with on, off, and emit methods\n */\nexport function createEventEmitter() {\n  const events = {};\n\n  return {\n    on(event, callback) {\n      if (!events[event]) {\n        events[event] = [];\n      }\n      events[event].push(callback);\n    },\n\n    off(event, callback) {\n      if (!events[event]) return;\n\n      if (callback) {\n        const index = events[event].indexOf(callback);\n        if (index > -1) {\n          events[event].splice(index, 1);\n        }\n      } else {\n        events[event] = [];\n      }\n    },\n\n    emit(event, ...args) {\n      if (!events[event]) return;\n      events[event].forEach(callback => callback(...args));\n    },\n  };\n}\n", "/**\n * Configuration management for JustGage\n */\n\nimport { kvLookup, uuid, extend, isUndefined } from '../utils/helpers.js';\n\n/**\n * Gauge geometry constants\n */\nexport const GAUGE_WIDTH_DIVISOR = 20 / 3; // 6.666666666666667 - divisor for calculating inner radius\n\n/**\n * Default configuration values\n */\nexport const DEFAULT_CONFIG = {\n  value: 0,\n  min: 0,\n  max: 100,\n  reverse: false,\n  gaugeWidthScale: 1.0,\n  gaugeColor: '#edebeb',\n  label: '',\n  valueFontColor: '#010101',\n  valueFontFamily: 'Arial',\n  labelFontColor: '#b3b3b3',\n  labelFontFamily: 'Arial',\n  symbol: '',\n  shadowOpacity: 0.2,\n  shadowSize: 5,\n  shadowVerticalOffset: 3,\n  levelColors: ['#a9d70b', '#f9c802', '#ff0000'],\n  startAnimationTime: 700,\n  startAnimationType: '>',\n  refreshAnimationTime: 700,\n  refreshAnimationType: '>',\n  donutStartAngle: 90,\n  valueMinFontSize: 16,\n  labelMinFontSize: 10,\n  minLabelMinFontSize: 10,\n  maxLabelMinFontSize: 10,\n  titleMinFontSize: 10,\n  hideValue: false,\n  hideMinMax: false,\n  showMinMax: true,\n  showInnerShadow: false,\n  humanFriendly: false,\n  humanFriendlyDecimal: 0,\n  noGradient: false,\n  donut: false,\n  differential: false,\n  relativeGaugeSize: false,\n  counter: false,\n  decimals: 0,\n  customSectors: {},\n  formatNumber: false,\n  pointer: false,\n  pointerOptions: {},\n  displayRemaining: false,\n  targetLine: null,\n  targetLineColor: '#000000',\n  targetLineWidth: 1.5,\n  textRenderer: null,\n  onAnimationEnd: null,\n  showSectorColors: false,\n  minTxt: false,\n  maxTxt: false,\n  defaults: false,\n  parentNode: null,\n  width: null,\n  height: null,\n  title: '',\n  titleFontColor: '#999999',\n  titleFontFamily: 'Arial',\n  titleFontWeight: 'bold',\n  titlePosition: 'above', // above|below\n  valueFontWeight: 'normal',\n  labelFontWeight: 'normal',\n};\n\n/**\n * Create and validate configuration object\n * @param {object} config - User configuration\n * @param {object} dataset - Dataset from DOM element\n * @returns {object} Processed configuration\n */\nexport function createConfig(config, dataset = {}) {\n  if (isUndefined(config)) {\n    throw new Error('JustGage: Configuration object is required');\n  }\n\n  const { defaults, ...restConfig } = config;\n  if (defaults) {\n    config = extend({}, defaults, restConfig);\n  }\n\n  /** @type {import('../types/index.d.ts').JustGageConfig} */\n  const processedConfig = {\n    // Generate unique class ID for styling\n    classId: uuid(),\n\n    // Core identification\n    id: config.id,\n    parentNode: kvLookup('parentNode', config, dataset, null),\n\n    // Dimensions\n    width: kvLookup('width', config, dataset, DEFAULT_CONFIG.width),\n    height: kvLookup('height', config, dataset, DEFAULT_CONFIG.height),\n\n    // Value settings\n    value: kvLookup('value', config, dataset, DEFAULT_CONFIG.value, 'float'),\n    min: kvLookup('min', config, dataset, DEFAULT_CONFIG.min, 'float'),\n    max: kvLookup('max', config, dataset, DEFAULT_CONFIG.max, 'float'),\n    minTxt: kvLookup('minTxt', config, dataset, DEFAULT_CONFIG.minTxt),\n    maxTxt: kvLookup('maxTxt', config, dataset, DEFAULT_CONFIG.maxTxt),\n    reverse: kvLookup('reverse', config, dataset, DEFAULT_CONFIG.reverse),\n\n    // Display settings\n    symbol: kvLookup('symbol', config, dataset, DEFAULT_CONFIG.symbol),\n    decimals: kvLookup('decimals', config, dataset, DEFAULT_CONFIG.decimals),\n    counter: kvLookup('counter', config, dataset, DEFAULT_CONFIG.counter),\n    hideValue: kvLookup('hideValue', config, dataset, DEFAULT_CONFIG.hideValue),\n    hideMinMax: kvLookup('hideMinMax', config, dataset, DEFAULT_CONFIG.hideMinMax),\n    showMinMax: kvLookup('showMinMax', config, dataset, DEFAULT_CONFIG.showMinMax),\n\n    // Fonts and colors\n    valueFontColor: kvLookup('valueFontColor', config, dataset, DEFAULT_CONFIG.valueFontColor),\n    valueFontFamily: kvLookup('valueFontFamily', config, dataset, DEFAULT_CONFIG.valueFontFamily),\n    labelFontColor: kvLookup('labelFontColor', config, dataset, DEFAULT_CONFIG.labelFontColor),\n    labelFontFamily: kvLookup('labelFontFamily', config, dataset, DEFAULT_CONFIG.labelFontFamily),\n\n    // Font sizes\n    valueMinFontSize: kvLookup(\n      'valueMinFontSize',\n      config,\n      dataset,\n      DEFAULT_CONFIG.valueMinFontSize\n    ),\n    labelMinFontSize: kvLookup(\n      'labelMinFontSize',\n      config,\n      dataset,\n      DEFAULT_CONFIG.labelMinFontSize\n    ),\n    minLabelMinFontSize: kvLookup(\n      'minLabelMinFontSize',\n      config,\n      dataset,\n      DEFAULT_CONFIG.minLabelMinFontSize\n    ),\n    maxLabelMinFontSize: kvLookup(\n      'maxLabelMinFontSize',\n      config,\n      dataset,\n      DEFAULT_CONFIG.maxLabelMinFontSize\n    ),\n    titleMinFontSize: kvLookup(\n      'titleMinFontSize',\n      config,\n      dataset,\n      DEFAULT_CONFIG.titleMinFontSize\n    ),\n\n    // Gauge appearance\n    gaugeWidthScale: kvLookup('gaugeWidthScale', config, dataset, DEFAULT_CONFIG.gaugeWidthScale),\n    gaugeColor: kvLookup('gaugeColor', config, dataset, DEFAULT_CONFIG.gaugeColor),\n    levelColors: kvLookup('levelColors', config, dataset, DEFAULT_CONFIG.levelColors),\n    noGradient: kvLookup('noGradient', config, dataset, DEFAULT_CONFIG.noGradient),\n\n    // Shadow settings\n    shadowOpacity: kvLookup('shadowOpacity', config, dataset, DEFAULT_CONFIG.shadowOpacity),\n    shadowSize: kvLookup('shadowSize', config, dataset, DEFAULT_CONFIG.shadowSize),\n    shadowVerticalOffset: kvLookup(\n      'shadowVerticalOffset',\n      config,\n      dataset,\n      DEFAULT_CONFIG.shadowVerticalOffset\n    ),\n    showInnerShadow: kvLookup('showInnerShadow', config, dataset, DEFAULT_CONFIG.showInnerShadow),\n\n    // Animation settings\n    startAnimationTime: kvLookup(\n      'startAnimationTime',\n      config,\n      dataset,\n      DEFAULT_CONFIG.startAnimationTime\n    ),\n    startAnimationType: kvLookup(\n      'startAnimationType',\n      config,\n      dataset,\n      DEFAULT_CONFIG.startAnimationType\n    ),\n    refreshAnimationTime: kvLookup(\n      'refreshAnimationTime',\n      config,\n      dataset,\n      DEFAULT_CONFIG.refreshAnimationTime\n    ),\n    refreshAnimationType: kvLookup(\n      'refreshAnimationType',\n      config,\n      dataset,\n      DEFAULT_CONFIG.refreshAnimationType\n    ),\n\n    // Gauge types\n    donut: kvLookup('donut', config, dataset, DEFAULT_CONFIG.donut),\n    donutStartAngle: kvLookup('donutStartAngle', config, dataset, DEFAULT_CONFIG.donutStartAngle),\n    differential: kvLookup('differential', config, dataset, DEFAULT_CONFIG.differential),\n    relativeGaugeSize: kvLookup(\n      'relativeGaugeSize',\n      config,\n      dataset,\n      DEFAULT_CONFIG.relativeGaugeSize\n    ),\n\n    // Advanced features\n    customSectors: kvLookup('customSectors', config, dataset, DEFAULT_CONFIG.customSectors),\n    pointer: kvLookup('pointer', config, dataset, DEFAULT_CONFIG.pointer),\n    pointerOptions: kvLookup('pointerOptions', config, dataset, DEFAULT_CONFIG.pointerOptions),\n    targetLine: kvLookup('targetLine', config, dataset, DEFAULT_CONFIG.targetLine, 'float'),\n    targetLineColor: kvLookup('targetLineColor', config, dataset, DEFAULT_CONFIG.targetLineColor),\n    targetLineWidth: kvLookup('targetLineWidth', config, dataset, DEFAULT_CONFIG.targetLineWidth),\n\n    // Number formatting\n    humanFriendly: kvLookup('humanFriendly', config, dataset, DEFAULT_CONFIG.humanFriendly),\n    humanFriendlyDecimal: kvLookup(\n      'humanFriendlyDecimal',\n      config,\n      dataset,\n      DEFAULT_CONFIG.humanFriendlyDecimal\n    ),\n    formatNumber: kvLookup('formatNumber', config, dataset, DEFAULT_CONFIG.formatNumber),\n    displayRemaining: kvLookup(\n      'displayRemaining',\n      config,\n      dataset,\n      DEFAULT_CONFIG.displayRemaining\n    ),\n\n    // Label\n    label: kvLookup('label', config, dataset, DEFAULT_CONFIG.label),\n\n    // Title configuration\n    title: kvLookup('title', config, dataset, DEFAULT_CONFIG.title),\n    titleFontColor: kvLookup('titleFontColor', config, dataset, DEFAULT_CONFIG.titleFontColor),\n    titleFontFamily: kvLookup('titleFontFamily', config, dataset, DEFAULT_CONFIG.titleFontFamily),\n    titleFontWeight: kvLookup('titleFontWeight', config, dataset, DEFAULT_CONFIG.titleFontWeight),\n    titlePosition: kvLookup('titlePosition', config, dataset, DEFAULT_CONFIG.titlePosition),\n\n    // Value font configuration\n    valueFontWeight: kvLookup('valueFontWeight', config, dataset, DEFAULT_CONFIG.valueFontWeight),\n\n    // Label font configuration\n    labelFontWeight: kvLookup('labelFontWeight', config, dataset, DEFAULT_CONFIG.labelFontWeight),\n\n    // Callbacks\n    textRenderer: kvLookup('textRenderer', config, dataset, DEFAULT_CONFIG.textRenderer),\n    onAnimationEnd: kvLookup('onAnimationEnd', config, dataset, DEFAULT_CONFIG.onAnimationEnd),\n\n    // Sector colors visualization\n    showSectorColors: kvLookup(\n      'showSectorColors',\n      config,\n      dataset,\n      DEFAULT_CONFIG.showSectorColors\n    ),\n  };\n\n  return validateConfig(processedConfig);\n}\n\n/**\n * Validate configuration values\n * @param {object} config - Configuration to validate\n * @returns {object} Validated configuration\n */\nfunction validateConfig(config) {\n  // Allow values outside min/max range - they will be clamped visually but displayed as-is\n  // Visual clamping happens in _drawLevel and _drawPointer methods\n\n  // Validate required fields\n  if (!config.id && !config.parentNode) {\n    throw new Error('JustGage: Either id or parentNode must be provided');\n  }\n\n  // Validate min/max range\n  if (config.min >= config.max) {\n    throw new Error('JustGage: min value must be less than max value');\n  }\n\n  // Ensure levelColors is a valid array\n  if (!Array.isArray(config.levelColors) || config.levelColors.length === 0) {\n    config.levelColors = DEFAULT_CONFIG.levelColors;\n  }\n\n  return config;\n}\n", "/**\n * Native SVG rendering functions\n * Replaces RaphaelJS dependency with browser-native SVG APIs\n */\n\n/**\n * Utility function to create SVG elements\n * @param {string} tagName - SVG element tag name\n * @returns {SVGElement} Created SVG element\n */\nconst createSVGElement = tagName => {\n  return document.createElementNS('http://www.w3.org/2000/svg', tagName);\n};\n\n/**\n * SVG Renderer for JustGage - Modern implementation using native SVG APIs\n * Replaces RaphaelJS dependency from v1.x\n */\n\nimport { GAUGE_WIDTH_DIVISOR } from '../core/config.js';\nexport class SVGRenderer {\n  /**\n   * Create a new SVG renderer instance\n   *\n   * @param {HTMLElement} container - DOM element to render SVG into\n   * @param {number|string} width - SVG canvas width (pixels or percentage)\n   * @param {number|string} height - SVG canvas height (pixels or percentage)\n   * @param {number} [viewBoxWidth] - ViewBox width (defaults to width)\n   * @param {number} [viewBoxHeight] - ViewBox height (defaults to height)\n   */\n  constructor(container, width, height, viewBoxWidth, viewBoxHeight) {\n    this.container = container;\n    this.width = width;\n    this.height = height;\n    this.viewBoxWidth = viewBoxWidth || width;\n    this.viewBoxHeight = viewBoxHeight || height;\n    this.svg = null;\n    this.elements = new Map();\n    this.init();\n  }\n\n  init() {\n    // Create SVG element\n    this.svg = createSVGElement('svg');\n    this.svg.setAttribute('width', this.width);\n    this.svg.setAttribute('height', this.height);\n    this.svg.setAttribute('viewBox', `0 0 ${this.viewBoxWidth} ${this.viewBoxHeight}`);\n    this.svg.style.overflow = 'hidden';\n\n    // Enable responsive scaling when using relative sizing\n    if (typeof this.width === 'string' && this.width.includes('%')) {\n      this.svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');\n    }\n\n    // Clear container and add SVG\n    this.container.innerHTML = '';\n    this.container.appendChild(this.svg);\n  }\n\n  /**\n   * Create a circle element\n   */\n  circle(cx, cy, radius) {\n    const circle = createSVGElement('circle');\n    circle.setAttribute('cx', cx);\n    circle.setAttribute('cy', cy);\n    circle.setAttribute('r', radius);\n    this.svg.appendChild(circle);\n\n    return new SVGElement(circle);\n  }\n\n  /**\n   * Create a rectangle element\n   */\n  rect(x, y, width, height) {\n    const rect = createSVGElement('rect');\n    rect.setAttribute('x', x);\n    rect.setAttribute('y', y);\n    rect.setAttribute('width', width);\n    rect.setAttribute('height', height);\n    this.svg.appendChild(rect);\n\n    return new SVGElement(rect);\n  }\n\n  /**\n   * Create a path element\n   */\n  path(pathData) {\n    const path = createSVGElement('path');\n    path.setAttribute('d', pathData);\n    this.svg.appendChild(path);\n\n    return new SVGElement(path);\n  }\n\n  /**\n   * Create a line element\n   */\n  line(x1, y1, x2, y2) {\n    const line = createSVGElement('line');\n    line.setAttribute('x1', x1);\n    line.setAttribute('y1', y1);\n    line.setAttribute('x2', x2);\n    line.setAttribute('y2', y2);\n    this.svg.appendChild(line);\n\n    return new SVGElement(line);\n  }\n\n  /**\n   * Create a text element\n   */\n  text(x, y, content) {\n    const text = createSVGElement('text');\n    text.setAttribute('x', x);\n    text.setAttribute('y', y);\n    text.textContent = content;\n    this.svg.appendChild(text);\n\n    return new SVGElement(text);\n  }\n\n  /**\n   * Create an arc/sector path\n   */\n  sector(cx, cy, r1, r2, startAngle, endAngle) {\n    const pathData = this.createSectorPath(cx, cy, r1, r2, startAngle, endAngle);\n    return this.path(pathData);\n  }\n\n  /**\n   * Generate SVG path data for an arc sector matching original JustGage\n   */\n  createSectorPath(cx, cy, r1, r2, startAngle, endAngle) {\n    const rad1 = ((startAngle - 90) * Math.PI) / 180;\n    const rad2 = ((endAngle - 90) * Math.PI) / 180;\n\n    const x1 = cx + r1 * Math.cos(rad1);\n    const y1 = cy + r1 * Math.sin(rad1);\n    const x2 = cx + r2 * Math.cos(rad1);\n    const y2 = cy + r2 * Math.sin(rad1);\n    const x3 = cx + r2 * Math.cos(rad2);\n    const y3 = cy + r2 * Math.sin(rad2);\n    const x4 = cx + r1 * Math.cos(rad2);\n    const y4 = cy + r1 * Math.sin(rad2);\n\n    // Handle angle wrapping for large arc flag\n    let angleSpan = endAngle - startAngle;\n    if (angleSpan <= 0) {\n      angleSpan += 360;\n    }\n    const largeArcFlag = angleSpan > 180 ? 1 : 0;\n\n    return [\n      `M ${x1} ${y1}`,\n      `L ${x2} ${y2}`,\n      `A ${r2} ${r2} 0 ${largeArcFlag} 1 ${x3} ${y3}`,\n      `L ${x4} ${y4}`,\n      `A ${r1} ${r1} 0 ${largeArcFlag} 0 ${x1} ${y1}`,\n      'Z',\n    ].join(' ');\n  }\n\n  /**\n   * Create gauge path\n   * @param {number|{from: number, to: number}} sectorPctOrValue\n   * @param {number} min\n   * @param {number} max\n   * @param {number} widgetW\n   * @param {number} widgetH\n   * @param {number} dx\n   * @param {number} dy\n   * @param {number} gaugeWidthScale\n   * @param {boolean} donut\n   * @param {boolean} isDiff\n   * @returns {string} SVG path data for the gauge\n   */\n  createGaugePath(\n    sectorPctOrValue,\n    min,\n    max,\n    widgetW,\n    widgetH,\n    dx,\n    dy,\n    gaugeWidthScale,\n    donut = false,\n    isDiff = false\n  ) {\n    let alpha; // angle in radians\n    let Ro; // outer radius, from center to outer edge of gauge\n    let Ri; // inner radius, from center to inner edge of gauge\n    let Cx; // center x\n    let Cy; // center y\n    let Xo, Yo, Xi, Yi; // outer and inner arc endpoints\n    let Xstart, Ystart, XstartInner, YstartInner; // start point coordinates\n    let path; // SVG path string\n\n    // Track if sector was originally a number (absolute value)\n    const sectorWasNumber = typeof sectorPctOrValue === 'number';\n\n    if (min < 0 && !isDiff) {\n      max -= min;\n      if (sectorWasNumber) {\n        sectorPctOrValue -= min;\n      }\n      min = 0;\n    }\n\n    if (sectorWasNumber) {\n      sectorPctOrValue = { from: min, to: sectorPctOrValue };\n    }\n\n    // Calculate range (needed for differential gauge middle calculation)\n    const range = max - min;\n\n    // Determine percentage values based on input format\n    let pctStart, pctEnd;\n\n    if (sectorWasNumber) {\n      // When sector was a number, it's an absolute value, so convert it\n      const deltaVStart = sectorPctOrValue.from - min;\n      const deltaVEnd = sectorPctOrValue.to - min;\n      pctStart = deltaVStart / range;\n      pctEnd = deltaVEnd / range;\n    } else if (\n      typeof sectorPctOrValue.from === 'number' &&\n      typeof sectorPctOrValue.to === 'number'\n    ) {\n      // Sector is an object, check if values are normalized (0-1) or percentage (0-100)\n      if (sectorPctOrValue.from <= 1 && sectorPctOrValue.to <= 1) {\n        // Already normalized (0-1 range)\n        pctStart = sectorPctOrValue.from;\n        pctEnd = sectorPctOrValue.to;\n      } else {\n        // Percentage format (0-100 range), convert to 0-1\n        pctStart = sectorPctOrValue.from / 100;\n        pctEnd = sectorPctOrValue.to / 100;\n      }\n    } else {\n      // Fallback: treat as absolute values (legacy behavior)\n      const deltaVStart = sectorPctOrValue.from - min;\n      const deltaVEnd = sectorPctOrValue.to - min;\n      pctStart = deltaVStart / range;\n      pctEnd = deltaVEnd / range;\n    }\n\n    if (donut) {\n      // Calculate end point angle\n      alpha = (1 - 2 * pctEnd) * Math.PI;\n      Ro = widgetW / 2 - widgetW / 30;\n      Ri = Ro - (widgetW / GAUGE_WIDTH_DIVISOR) * gaugeWidthScale;\n\n      Cx = widgetW / 2 + dx;\n      Cy = widgetH / 2 + dy;\n\n      Xo = Cx + Ro * Math.cos(alpha);\n      Yo = Cy - Ro * Math.sin(alpha);\n      Xi = Cx + Ri * Math.cos(alpha);\n      Yi = Cy - Ri * Math.sin(alpha);\n\n      // Calculate start point angle\n      const alphaStart = (1 - 2 * pctStart) * Math.PI;\n      Xstart = Cx + Ro * Math.cos(alphaStart);\n      Ystart = Cy - Ro * Math.sin(alphaStart);\n      XstartInner = Cx + Ri * Math.cos(alphaStart);\n      YstartInner = Cy - Ri * Math.sin(alphaStart);\n\n      // Calculate the angular span of the sector\n      const angularSpan = Math.abs(pctEnd - pctStart);\n\n      // Special case: full circle (or very close to it)\n      if (angularSpan >= 0.999) {\n        // Draw as two semicircles to avoid SVG not rendering when start = end\n        const XmidOuter = Cx + Ro;\n        const YmidOuter = Cy;\n        const XmidInner = Cx + Ri;\n        const YmidInner = Cy;\n\n        path = 'M' + XstartInner + ',' + YstartInner + ' ';\n        path += 'L' + Xstart + ',' + Ystart + ' ';\n        // First half of outer circle\n        path += 'A' + Ro + ',' + Ro + ' 0 0 1 ' + XmidOuter + ',' + YmidOuter + ' ';\n        // Second half of outer circle\n        path += 'A' + Ro + ',' + Ro + ' 0 0 1 ' + Xstart + ',' + Ystart + ' ';\n        path += 'L' + XstartInner + ',' + YstartInner + ' ';\n        // First half of inner circle (reverse direction)\n        path += 'A' + Ri + ',' + Ri + ' 0 0 0 ' + XmidInner + ',' + YmidInner + ' ';\n        // Second half of inner circle (reverse direction)\n        path += 'A' + Ri + ',' + Ri + ' 0 0 0 ' + XstartInner + ',' + YstartInner + ' ';\n        path += 'Z ';\n      } else {\n        // Normal sector arc\n        const largeArcFlag = angularSpan > 0.5 ? 1 : 0;\n\n        path = 'M' + XstartInner + ',' + YstartInner + ' ';\n        path += 'L' + Xstart + ',' + Ystart + ' ';\n        // Draw outer arc from start to end point\n        path += 'A' + Ro + ',' + Ro + ' 0 ' + largeArcFlag + ' 1 ' + Xo + ',' + Yo + ' ';\n        path += 'L' + Xi + ',' + Yi + ' ';\n        // Draw inner arc from end back to start point\n        path +=\n          'A' +\n          Ri +\n          ',' +\n          Ri +\n          ' 0 ' +\n          largeArcFlag +\n          ' 0 ' +\n          XstartInner +\n          ',' +\n          YstartInner +\n          ' ';\n        path += 'Z ';\n      }\n    } else if (isDiff) {\n      // Calculate end point angle\n      alpha = (1 - pctEnd) * Math.PI;\n      Ro = widgetW / 2 - widgetW / 10;\n      Ri = Ro - (widgetW / GAUGE_WIDTH_DIVISOR) * gaugeWidthScale;\n\n      Cx = widgetW / 2 + dx;\n      Cy = widgetH / 1.25 + dy;\n\n      Xo = Cx + Ro * Math.cos(alpha);\n      Yo = Cy - Ro * Math.sin(alpha);\n      Xi = Cx + Ri * Math.cos(alpha);\n      Yi = Cy - Ri * Math.sin(alpha);\n\n      const middlePct = 0.5; // 50% is the middle of the differential gauge\n      const So = pctEnd < middlePct ? 1 : 0; // sweep flag for outer arc, use opposite direction if value < middle\n      const Si = pctEnd < middlePct ? 0 : 1; // sweep flag for inner arc, use opposite direction if value < middle\n\n      path = 'M' + Cx + ',' + (Cy - Ri) + ' '; // start at bottom center\n      path += 'L' + Cx + ',' + (Cy - Ro) + ' '; // line to top center (Cx, Cy - Ro)\n      path += 'A' + Ro + ',' + Ro + ' 0 0 ' + Si + ' ' + Xo + ',' + Yo + ' '; // arc to outer edge\n      path += 'L' + Xi + ',' + Yi + ' '; // line to inner edge (Xi, Yi)\n      path += 'A' + Ri + ',' + Ri + ' 0 0 ' + So + ' ' + Cx + ',' + (Cy - Ri) + ' '; // arc to bottom center\n      path += 'Z '; // close path\n    } else {\n      // Standard gauge\n      // Calculate end point angle\n      alpha = (1 - pctEnd) * Math.PI;\n      Ro = widgetW / 2 - widgetW / 10;\n      Ri = Ro - (widgetW / GAUGE_WIDTH_DIVISOR) * gaugeWidthScale;\n\n      Cx = widgetW / 2 + dx;\n      Cy = widgetH / 1.25 + dy;\n\n      Xo = Cx + Ro * Math.cos(alpha);\n      Yo = Cy - Ro * Math.sin(alpha);\n      Xi = Cx + Ri * Math.cos(alpha);\n      Yi = Cy - Ri * Math.sin(alpha);\n\n      // Calculate start point angle\n      const alphaStart = (1 - pctStart) * Math.PI;\n      Xstart = Cx + Ro * Math.cos(alphaStart);\n      Ystart = Cy - Ro * Math.sin(alphaStart);\n      XstartInner = Cx + Ri * Math.cos(alphaStart);\n      YstartInner = Cy - Ri * Math.sin(alphaStart);\n\n      // Move to the starting point at the inner edge\n      path = 'M' + XstartInner + ',' + YstartInner + ' ';\n      // Draw a line to the outer start point\n      path += 'L' + Xstart + ',' + Ystart + ' ';\n      // Draw the outer arc from start to the calculated arc endpoint (Xo, Yo)\n      path += 'A' + Ro + ',' + Ro + ' 0 0 1 ' + Xo + ',' + Yo + ' ';\n      // Draw a line from the outer arc endpoint to the corresponding inner arc endpoint\n      path += 'L' + Xi + ',' + Yi + ' ';\n      // Draw the inner arc back to the starting inner point\n      path += 'A' + Ri + ',' + Ri + ' 0 0 0 ' + XstartInner + ',' + YstartInner + ' ';\n      // Close the path to complete the gauge sector\n      path += 'Z ';\n    }\n\n    return path;\n  }\n\n  /**\n   * Create gauge pointer using path data (removed - now using direct path creation)\n   * Pointers are now created directly using the path() method with original JustGage algorithm\n   */\n\n  /**\n   * Remove all elements from SVG\n   */\n  clear() {\n    while (this.svg.firstChild) {\n      this.svg.removeChild(this.svg.firstChild);\n    }\n    this.elements.clear();\n  }\n\n  /**\n   * Remove the entire SVG from DOM\n   */\n  remove() {\n    if (this.svg && this.svg.parentNode) {\n      this.svg.parentNode.removeChild(this.svg);\n    }\n    this.elements.clear();\n  }\n\n  /**\n   * Create or get defs element for filters and gradients\n   * @returns {SVGElement} The defs element\n   */\n  getDefs() {\n    let defs = this.svg.querySelector('defs');\n    if (!defs) {\n      defs = createSVGElement('defs');\n      this.svg.appendChild(defs);\n    }\n    return defs;\n  }\n\n  /**\n   * Generate shadow filter for inner shadow effect\n   * @param {string} shadowId - Unique ID for the shadow filter\n   * @param {object} shadowConfig - Shadow configuration options\n   * @param {number} shadowConfig.verticalOffset - Vertical offset for shadow\n   * @param {number} shadowConfig.size - Blur size for shadow\n   * @param {number} shadowConfig.opacity - Shadow opacity (0-1)\n   * @returns {string} The shadow filter ID\n   */\n  createShadowFilter(shadowId, shadowConfig) {\n    const defs = this.getDefs();\n\n    // Remove existing filter if it exists\n    const existingFilter = defs.querySelector(`#${shadowId}`);\n    if (existingFilter) {\n      existingFilter.remove();\n    }\n\n    // Create filter element\n    const filter = createSVGElement('filter');\n    filter.setAttribute('id', shadowId);\n    defs.appendChild(filter);\n\n    // Create offset for shadow\n    const feOffset = createSVGElement('feOffset');\n    feOffset.setAttribute('dx', 0);\n    feOffset.setAttribute('dy', shadowConfig.verticalOffset || 0);\n    filter.appendChild(feOffset);\n\n    // Create blur effect\n    const feGaussianBlur = createSVGElement('feGaussianBlur');\n    feGaussianBlur.setAttribute('result', 'offset-blur');\n    feGaussianBlur.setAttribute('stdDeviation', shadowConfig.size || 0);\n    filter.appendChild(feGaussianBlur);\n\n    // Create composite for inverse\n    const feComposite1 = createSVGElement('feComposite');\n    feComposite1.setAttribute('operator', 'out');\n    feComposite1.setAttribute('in', 'SourceGraphic');\n    feComposite1.setAttribute('in2', 'offset-blur');\n    feComposite1.setAttribute('result', 'inverse');\n    filter.appendChild(feComposite1);\n\n    // Create flood for shadow color\n    const feFlood = createSVGElement('feFlood');\n    feFlood.setAttribute('flood-color', 'black');\n    feFlood.setAttribute('flood-opacity', shadowConfig.opacity || 0.5);\n    feFlood.setAttribute('result', 'color');\n    filter.appendChild(feFlood);\n\n    // Create composite for shadow\n    const feComposite2 = createSVGElement('feComposite');\n    feComposite2.setAttribute('operator', 'in');\n    feComposite2.setAttribute('in', 'color');\n    feComposite2.setAttribute('in2', 'inverse');\n    feComposite2.setAttribute('result', 'shadow');\n    filter.appendChild(feComposite2);\n\n    // Create final composite\n    const feComposite3 = createSVGElement('feComposite');\n    feComposite3.setAttribute('operator', 'over');\n    feComposite3.setAttribute('in', 'shadow');\n    feComposite3.setAttribute('in2', 'SourceGraphic');\n    filter.appendChild(feComposite3);\n\n    return shadowId;\n  }\n\n  /**\n   * Apply shadow filter to elements\n   * @param {string} shadowId - Shadow filter ID\n   * @param {SVGElement[]} elements - Elements to apply shadow to\n   */\n  applyShadowToElements(shadowId, elements) {\n    elements.forEach(element => {\n      if (element && element.attr) {\n        element.attr({ filter: `url(#${shadowId})` });\n      }\n    });\n  }\n\n  /**\n   * Remove shadow filter from elements\n   * @param {SVGElement[]} elements - Elements to remove shadow from\n   */\n  removeShadowFromElements(elements) {\n    elements.forEach(element => {\n      if (element && element.attr) {\n        element.attr({ filter: 'none' });\n      }\n    });\n  }\n}\n\n/**\n * Wrapper class for SVG elements to provide Raphael-like API\n */\nexport class SVGElement {\n  constructor(element) {\n    this.element = element;\n  }\n\n  /**\n   * Set element attributes\n   */\n  attr(attrs) {\n    if (typeof attrs === 'string') {\n      return this.element.getAttribute(attrs);\n    }\n\n    Object.keys(attrs).forEach(key => {\n      const value = attrs[key];\n\n      // Handle special attribute mappings\n      switch (key) {\n        case 'text':\n          // For SVG text elements, set textContent instead of attribute\n          this.element.textContent = value;\n          break;\n        case 'fill':\n          this.element.setAttribute('fill', value);\n          break;\n        case 'stroke':\n          this.element.setAttribute('stroke', value);\n          break;\n        case 'stroke-width':\n        case 'strokeWidth':\n          this.element.setAttribute('stroke-width', value);\n          break;\n        case 'opacity':\n          this.element.setAttribute('opacity', value);\n          break;\n        case 'font-family':\n        case 'fontFamily':\n          this.element.setAttribute('font-family', value);\n          break;\n        case 'font-size':\n        case 'fontSize':\n          this.element.setAttribute('font-size', value);\n          break;\n        case 'font-weight':\n        case 'fontWeight':\n          this.element.setAttribute('font-weight', value);\n          break;\n        case 'text-anchor':\n        case 'textAnchor':\n          this.element.setAttribute('text-anchor', value);\n          break;\n        case 'dominant-baseline':\n        case 'dominantBaseline':\n          this.element.setAttribute('dominant-baseline', value);\n          break;\n        case 'filter':\n          this.element.setAttribute('filter', value);\n          break;\n        default:\n          this.element.setAttribute(key, value);\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Remove element from DOM\n   */\n  remove() {\n    if (this.element && this.element.parentNode) {\n      this.element.parentNode.removeChild(this.element);\n    }\n    return this;\n  }\n\n  /**\n   * Hide element\n   */\n  hide() {\n    this.element.style.display = 'none';\n    return this;\n  }\n\n  /**\n   * Show element\n   */\n  show() {\n    this.element.style.display = '';\n    return this;\n  }\n\n  /**\n   * Set element text content\n   */\n  text(content) {\n    if (content === undefined) {\n      return this.element.textContent;\n    }\n    this.element.textContent = content;\n    return this;\n  }\n\n  /**\n   * Apply transform to element\n   * @param {string} transform - Transform string (e.g., 'rotate(90 50 50)')\n   */\n  transform(transform) {\n    if (transform === undefined) {\n      return this.element.getAttribute('transform');\n    }\n    this.element.setAttribute('transform', transform);\n    return this;\n  }\n}\n", "/**\n * Color manipulation utilities\n */\n\n/**\n * Remove # from hex color string\n * @param {string} str - Hex color string\n * @returns {string} Hex color without #\n */\nexport function cutHex(str) {\n  return str.charAt(0) === '#' ? str.substring(1, 7) : str;\n}\n\n/**\n * Validate if string is a valid hex color\n * @param {string} val - String to validate\n * @returns {boolean} True if valid hex color\n */\nexport function isHexColor(val) {\n  const regExp = /^#([0-9A-Fa-f]{3}){1,2}$/;\n  return typeof val === 'string' && regExp.test(val);\n}\n\n/**\n * Get color for a value based on color scheme and custom sectors\n * @param {number} val - Current value\n * @param {number} pct - Percentage (0-1)\n * @param {string[]} col - Color array\n * @param {boolean} noGradient - Disable gradient\n * @param {import('../types/index.d.ts').CustomSectors} custSec - Custom sectors configuration\n * @returns {string} RGB color string\n */\nexport function getColor(val, pct, col, noGradient, custSec) {\n  let percentage, rval, gval, bval, lower, upper, range, rangePct, pctLower, pctUpper, color;\n  const cust = custSec && custSec.ranges && custSec.ranges.length > 0;\n  noGradient = noGradient || cust;\n\n  if (cust) {\n    if (custSec.percents === true) val = pct * 100;\n    for (let i = 0; i < custSec.ranges.length; i++) {\n      if (val >= custSec.ranges[i].lo && val <= custSec.ranges[i].hi) {\n        return custSec.ranges[i].color;\n      }\n    }\n  }\n\n  const no = col.length;\n  if (no === 1) return col[0];\n  const inc = noGradient ? 1 / no : 1 / (no - 1);\n  const colors = [];\n\n  for (let i = 0; i < col.length; i++) {\n    percentage = noGradient ? inc * (i + 1) : inc * i;\n    rval = parseInt(cutHex(col[i]).substring(0, 2), 16);\n    gval = parseInt(cutHex(col[i]).substring(2, 4), 16);\n    bval = parseInt(cutHex(col[i]).substring(4, 6), 16);\n    colors[i] = {\n      pct: percentage,\n      color: {\n        r: rval,\n        g: gval,\n        b: bval,\n      },\n    };\n  }\n\n  if (pct === 0) {\n    return `rgb(${[colors[0].color.r, colors[0].color.g, colors[0].color.b].join(',')})`;\n  }\n\n  for (let j = 0; j < colors.length; j++) {\n    if (pct <= colors[j].pct) {\n      if (noGradient) {\n        return `rgb(${[colors[j].color.r, colors[j].color.g, colors[j].color.b].join(',')})`;\n      } else {\n        lower = colors[j - 1] || colors[0];\n        upper = colors[j];\n        range = upper.pct - lower.pct;\n        rangePct = (pct - lower.pct) / range;\n        pctLower = 1 - rangePct;\n        pctUpper = rangePct;\n        color = {\n          r: Math.floor(lower.color.r * pctLower + upper.color.r * pctUpper),\n          g: Math.floor(lower.color.g * pctLower + upper.color.g * pctUpper),\n          b: Math.floor(lower.color.b * pctLower + upper.color.b * pctUpper),\n        };\n        return `rgb(${[color.r, color.g, color.b].join(',')})`;\n      }\n    }\n  }\n}\n", "/**\n * Number and text formatting utilities\n */\n\n/**\n * Format numbers with human-friendly suffixes (K, M, G, etc.)\n * @param {number} n - Number to format\n * @param {number} d - Decimal places\n * @returns {string} Formatted number with suffix\n */\nexport function humanFriendlyNumber(n, d) {\n  const d2 = Math.pow(10, d);\n  const s = ' KMGTPE';\n  let i = 0;\n  const c = 1000;\n\n  while ((n >= c || n <= -c) && ++i < s.length) {\n    n = n / c;\n  }\n\n  i = i >= s.length ? s.length - 1 : i;\n\n  return Math.round(n * d2) / d2 + s[i];\n}\n\n/**\n * Format numbers with comma separators\n * @param {number} x - Number to format\n * @returns {string} Formatted number with commas\n */\nexport function formatNumber(x) {\n  const parts = x.toString().split('.');\n  parts[0] = parts[0].replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',');\n  return parts.join('.');\n}\n", "/**\n * Animation manager for JustGage\n * Handles smooth animations for gauge elements using requestAnimationFrame\n */\nexport class GaugeAnimator {\n  constructor() {\n    this.currentAnimation = null;\n  }\n\n  /**\n   * Animate gauge from one value to another\n   * @param {Object} options - Animation options\n   * @param {number} options.fromValue - Starting value\n   * @param {number} options.toValue - Target value\n   * @param {number} options.duration - Animation duration in ms\n   * @param {string} options.easing - Easing type ('linear', '>', '<', '<>', 'bounce')\n   * @param {Function} options.onUpdate - Called each frame with current value\n   * @param {Function} [options.onComplete] - Called when animation completes\n   * @param {Function} [options.onCounterUpdate] - Called for counter text updates\n   */\n  animate({\n    fromValue,\n    toValue,\n    duration,\n    easing = 'linear',\n    onUpdate,\n    onComplete,\n    onCounterUpdate,\n  }) {\n    // Cancel any existing animation\n    this.cancel();\n\n    if (duration <= 0) {\n      // No animation, just call update with final value\n      if (onUpdate) onUpdate(toValue);\n      if (onCounterUpdate) onCounterUpdate(toValue);\n      if (onComplete) onComplete();\n      return;\n    }\n\n    const startTime = Date.now();\n    const valueRange = toValue - fromValue;\n\n    const animate = () => {\n      const elapsed = Date.now() - startTime;\n      const progress = Math.min(elapsed / duration, 1);\n\n      // Apply easing function\n      const easedProgress = this._applyEasing(progress, easing);\n      const currentValue = fromValue + valueRange * easedProgress;\n\n      // Update gauge elements\n      if (onUpdate) onUpdate(currentValue);\n      if (onCounterUpdate) onCounterUpdate(currentValue);\n\n      if (progress < 1) {\n        this.currentAnimation = requestAnimationFrame(animate);\n      } else {\n        // Animation complete\n        this.currentAnimation = null;\n        if (onUpdate) onUpdate(toValue);\n        if (onCounterUpdate) onCounterUpdate(toValue);\n        if (onComplete) onComplete();\n      }\n    };\n\n    // Start animation\n    this.currentAnimation = requestAnimationFrame(animate);\n  }\n\n  /**\n   * Cancel current animation\n   */\n  cancel() {\n    if (this.currentAnimation) {\n      cancelAnimationFrame(this.currentAnimation);\n      this.currentAnimation = null;\n    }\n  }\n\n  /**\n   * Apply easing function to progress\n   * Ref: https://github.com/DmitryBaranovskiy/raphael/blob/master/raphael.js#L4161\n   * @private\n   */\n  _applyEasing(progress, easing) {\n    switch (easing) {\n      case 'linear':\n      case '-':\n        return progress;\n      case '>':\n      case 'easeOut':\n      case 'ease-out':\n        return Math.pow(progress, 0.48);\n      case '<':\n      case 'easeIn':\n      case 'ease-in':\n        return Math.pow(progress, 1.7);\n      case '<>':\n      case 'easeInOut':\n      case 'ease-in-out':\n        return progress < 0.5 ? 2 * progress * progress : 1 - Math.pow(-2 * progress + 2, 2) / 2;\n      case 'bounce':\n        return this._bounceEasing(progress);\n      case 'elastic':\n        return (\n          Math.pow(2, -10 * progress) * Math.sin(((progress - 0.075) * (2 * Math.PI)) / 0.3) + 1\n        );\n      case 'backIn':\n      case 'back-in': {\n        const c1 = 1.70158;\n        const c3 = c1 + 1;\n        return c3 * progress * progress * progress - c1 * progress * progress;\n      }\n      case 'backOut':\n      case 'back-out': {\n        const c2 = 1.70158;\n        const c4 = c2 + 1;\n        return 1 + c4 * Math.pow(progress - 1, 3) + c2 * Math.pow(progress - 1, 2);\n      }\n      default:\n        return progress;\n    }\n  }\n\n  /**\n   * Bounce easing function\n   * @private\n   */\n  _bounceEasing(t) {\n    const n1 = 7.5625;\n    const d1 = 2.75;\n\n    if (t < 1 / d1) {\n      return n1 * t * t;\n    } else if (t < 2 / d1) {\n      return n1 * (t -= 1.5 / d1) * t + 0.75;\n    } else if (t < 2.5 / d1) {\n      return n1 * (t -= 2.25 / d1) * t + 0.9375;\n    } else {\n      return n1 * (t -= 2.625 / d1) * t + 0.984375;\n    }\n  }\n\n  /**\n   * Check if animation is currently running\n   */\n  isAnimating() {\n    return this.currentAnimation !== null;\n  }\n}\n", "import { createConfig, GAUGE_WIDTH_DIVISOR } from './config.js';\nimport { SVGRenderer } from '../rendering/svg.js';\nimport { isNumber } from '../utils/helpers.js';\nimport { isHexColor, getColor } from '../utils/colors.js';\nimport { formatNumber, humanFriendlyNumber } from '../utils/formatters.js';\nimport { GaugeAnimator } from './GaugeAnimator.js';\n\n/**\n * JustGage - Modern ES6+ implementation for creating animated SVG dashboard gauges.\n *\n * Features:\n * - Zero dependencies (native SVG APIs)\n * - ES6+ class-based architecture\n * - Full backward compatibility with v1.x\n * - Custom sectors and pointer support\n * - Responsive design\n *\n * @class JustGage\n * @example\n * // Basic usage\n * const gauge = new JustGage({\n *   id: 'my-gauge',\n *   value: 75,\n *   min: 0,\n *   max: 100,\n *   title: 'Performance'\n * });\n *\n * // With custom colors\n * const colorGauge = new JustGage({\n *   id: 'color-gauge',\n *   value: 60,\n *   levelColors: ['#green', '#yellow', '#red'],\n *   customSectors: {\n *     ranges: [\n *       { lo: 0, hi: 50, color: '#green' },\n *       { lo: 50, hi: 100, color: '#red' }\n *     ]\n *   }\n * });\n */\nexport class JustGage {\n  /**\n   * Create a new gauge instance\n   *\n   * @param {import('../types/index.d.ts').JustGageConfig} config - Configuration options for the gauge\n   * @throws {Error} When no configuration object is provided\n   * @throws {Error} When neither id nor parentNode is provided\n   * @throws {Error} When specified DOM element is not found\n   * @throws {Error} When min >= max\n   */\n  constructor(config) {\n    // Validate required container\n    if (!config) {\n      throw new Error('JustGage: Configuration object is required');\n    }\n\n    // Get container element\n    if (config.id) {\n      this.node = document.getElementById(config.id);\n      if (!this.node) {\n        throw new Error(`JustGage: No element with id '${config.id}' found`);\n      }\n    } else if (config.parentNode) {\n      this.node = config.parentNode;\n    } else {\n      throw new Error('JustGage: Either id or parentNode must be provided');\n    }\n\n    // Get dataset attributes\n    const dataset = this.node.dataset || {};\n\n    // Create and validate configuration\n    this.config = createConfig(config, dataset);\n    this.originalValue = config.value ?? -1;\n\n    // Initialize gauge\n    this._initializeGauge();\n  }\n\n  /**\n   * Initialize the gauge rendering\n   * @private\n   */\n  _initializeGauge() {\n    // Handle relative gauge sizing like legacy implementation\n    let width, height, viewBoxWidth, viewBoxHeight;\n\n    if (this.config.relativeGaugeSize) {\n      // Use percentage-based sizing with fixed viewBox dimensions\n      width = '100%';\n      height = '100%';\n\n      if (this.config.donut) {\n        // Donut gauges: square viewBox; add vertical room for title when present\n        viewBoxWidth = 200;\n        viewBoxHeight = this.config.title && this.config.title.length > 0 ? 240 : 200;\n      } else {\n        // Semi gauge: classic 2:1 viewBox; add room for title when present\n        viewBoxWidth = 200;\n        viewBoxHeight = this.config.title && this.config.title.length > 0 ? 150 : 100;\n      }\n    } else {\n      // Use fixed dimensions like current implementation\n      width = this.config.width;\n      height = this.config.height;\n\n      // If no dimensions specified, try to get from container\n      if (!width || !height) {\n        const rect = this.node.getBoundingClientRect();\n        if (!width) width = rect.width || 200;\n        if (!height) height = rect.height || 100;\n\n        // Update config with calculated dimensions\n        this.config.width = width;\n        this.config.height = height;\n      }\n\n      viewBoxWidth = width;\n      viewBoxHeight = height;\n    }\n\n    // Initialize SVG renderer with sizing configuration\n    this.renderer = new SVGRenderer(this.node, width, height, viewBoxWidth, viewBoxHeight);\n\n    // Store references to drawn elements\n    this.canvas = {\n      gauge: null,\n      level: null,\n      title: null,\n      value: null,\n      min: null,\n      max: null,\n      pointer: null,\n    };\n\n    // Initialize animator\n    this.animator = new GaugeAnimator();\n\n    // Draw the gauge\n    this._drawGauge();\n\n    // Apply shadows after gauge elements are created\n    if (this.config.showInnerShadow) {\n      this._initializeShadow();\n    }\n\n    // Start initial animation\n    this._startInitialAnimation();\n  }\n\n  /**\n   * Draw the complete gauge\n   * @private\n   */\n  _drawGauge() {\n    const config = this.config;\n\n    // Calculate widget dimensions using original algorithm\n    const { widgetW, widgetH, dx, dy } = this._calculateGaugeGeometry();\n\n    // Draw gauge background using original path generation\n    const gaugePath = this.renderer.createGaugePath(\n      config.max,\n      config.min,\n      config.max,\n      widgetW,\n      widgetH,\n      dx,\n      dy,\n      config.gaugeWidthScale || 1.0,\n      config.donut,\n      false // this is relevant only for level drawing\n    );\n\n    this.canvas.gauge = this.renderer.path(gaugePath).attr({\n      fill: config.gaugeColor,\n      stroke: 'none',\n    });\n\n    // Apply donut rotation to background gauge (like original)\n    this._applyDonutRotation(this.canvas.gauge, config, widgetW, widgetH, dx, dy);\n\n    // Draw value level or sector colors based on configuration\n    if (config.showSectorColors) {\n      // Draw static sector colors once (uses customSectors, levelColors, or gaugeColor)\n      this._drawSectorColors();\n    } else {\n      // Draw value level (start from appropriate value for animation)\n      // Differential gauges start from middle (0), regular gauges from min\n      const startValue = config.differential ? (config.max + config.min) / 2 : config.min;\n      this._drawLevel(startValue);\n    }\n\n    // Draw labels\n    this._drawLabels();\n\n    // Draw pointer if enabled\n    if (config.pointer) {\n      this._drawPointer();\n    }\n\n    this._drawTargetLine();\n  }\n\n  /**\n   * Draw gauge level (filled arc)\n   * @private\n   * @param {number} [animateValue] - If provided, draws level at this value instead of config.value\n   */\n  _drawLevel(animateValue) {\n    const config = this.config;\n\n    // If showSectorColors is enabled, skip drawing the level (sectors are drawn once during initialization)\n    if (config.showSectorColors) {\n      return;\n    }\n\n    // Use provided animate value or config value\n    const targetValue = animateValue !== undefined ? animateValue : config.value;\n\n    // Clamp value to min/max for visual representation\n    const clampedValue = this._clampValue(targetValue);\n\n    // Use consistent geometry calculations\n    const { widgetW, widgetH, dx, dy } = this._calculateGaugeGeometry();\n\n    // Calculate reversed value if needed (same as original implementation)\n    let displayValue = clampedValue;\n    if (config.reverse) {\n      displayValue = config.max + config.min - clampedValue;\n    }\n\n    // Get level color using clamped value (not reversed)\n    const color = this._getLevelColor(clampedValue);\n\n    // Draw level arc using original path generation with potentially reversed value\n    const levelPath = this.renderer.createGaugePath(\n      displayValue,\n      config.min,\n      config.max,\n      widgetW,\n      widgetH,\n      dx,\n      dy,\n      config.gaugeWidthScale || 1.0,\n      config.donut,\n      config.differential\n    );\n\n    if (this.canvas.level) {\n      // Update existing level\n      this.canvas.level.attr({\n        d: levelPath,\n        fill: color,\n      });\n    } else {\n      // Create new level\n      this.canvas.level = this.renderer.path(levelPath).attr({\n        fill: color,\n        stroke: 'none',\n      });\n\n      // Apply donut rotation to start from top (like original)\n      this._applyDonutRotation(this.canvas.level, config, widgetW, widgetH, dx, dy);\n    }\n  }\n\n  /**\n   * Draw sector colors as filled arcs\n   * @private\n   */\n  _drawSectorColors() {\n    const config = this.config;\n    const { widgetW, widgetH, dx, dy } = this._calculateGaugeGeometry();\n\n    // Clear existing sector elements if they exist\n    if (this.canvas.sectors) {\n      this.canvas.sectors.forEach(sector => sector.remove());\n    }\n    this.canvas.sectors = [];\n\n    // Determine sectors to draw\n    let sectors = [];\n\n    if (\n      config.customSectors &&\n      config.customSectors.ranges &&\n      config.customSectors.ranges.length > 0\n    ) {\n      // Use custom sectors as-is\n      sectors = config.customSectors.ranges.map(range => {\n        if (config.customSectors.percents) {\n          // Use lo/hi as percent values directly\n          return {\n            lo: range.lo,\n            hi: range.hi,\n            color: range.color,\n          };\n        } else {\n          const min = config.min;\n          const max = config.max;\n          const span = max - min;\n\n          return {\n            lo: (range.lo - min) / span,\n            hi: (range.hi - min) / span,\n            color: range.color,\n          };\n        }\n      });\n    } else if (Array.isArray(config.levelColors) && config.levelColors.length > 0) {\n      // Convert levelColors to sectors using the same logic as getColor function\n      const no = config.levelColors.length;\n      const inc = 1 / no; // Same as getColor with noGradient = true\n\n      sectors = config.levelColors.map((color, i) => {\n        const startPct = i * inc;\n        const endPct = (i + 1) * inc;\n        return {\n          lo: config.min + (config.max - config.min) * startPct,\n          hi: config.min + (config.max - config.min) * endPct,\n          color: color,\n        };\n      });\n    } else {\n      // No sectors to draw - let gauge background color handle it\n      return;\n    }\n\n    // Draw each sector\n    // Iterate from last sector to first\n    for (let i = sectors.length - 1; i >= 0; i--) {\n      const sector = sectors[i];\n\n      // Calculate start and end values, applying reverse if needed\n      let sectorMin = sector.lo;\n      let sectorMax = sector.hi;\n\n      if (config.reverse) {\n        const temp = config.max + config.min - sectorMax;\n        sectorMax = config.max + config.min - sectorMin;\n        sectorMin = temp;\n      }\n\n      // Create sector path using gauge path logic for the specific range\n      const sectorPath = this.renderer.createGaugePath(\n        { from: sectorMin, to: sectorMax },\n        config.min,\n        config.max,\n        widgetW,\n        widgetH,\n        dx,\n        dy,\n        config.gaugeWidthScale || 1.0,\n        config.donut\n      );\n\n      // Create sector element\n      const sectorElement = this.renderer.path(sectorPath).attr({\n        fill: sector.color,\n        stroke: 'none',\n      });\n\n      // Apply donut rotation if needed\n      this._applyDonutRotation(sectorElement, config, widgetW, widgetH, dx, dy);\n\n      // Store reference\n      this.canvas.sectors.push(sectorElement);\n    }\n  }\n\n  /**\n   * Calculate consistent gauge geometry for both arc and text positioning\n   * Uses caching to avoid redundant calculations\n   * @private\n   */\n  _calculateGaugeGeometry() {\n    const config = this.config;\n\n    // Use viewBox dimensions for relative sizing, otherwise use config dimensions\n    let w, h;\n    if (config.relativeGaugeSize) {\n      w = this.renderer.viewBoxWidth;\n      h = this.renderer.viewBoxHeight;\n    } else {\n      w = config.width;\n      h = config.height;\n    }\n\n    // Title space is handled through viewBox adjustments\n\n    // Calculate widget dimensions using legacy logic with title adjustments\n    let widgetW, widgetH, dx, dy;\n    if (config.donut) {\n      // Donut uses a square based on the smaller dimension to avoid overflow\n      const size = Math.min(w, h);\n      widgetW = size;\n      widgetH = size;\n      dx = (w - widgetW) / 2;\n      dy = (h - widgetH) / 2;\n    } else {\n      // For regular gauges, use legacy formula with title adjustments\n      if (w > h) {\n        // landscape\n        widgetH = h;\n        widgetW = widgetH * 2;\n        if (config.title.length > 0) {\n          widgetW = widgetH * 1.25;\n        }\n        if (widgetW > w) {\n          const aspect = widgetW / w;\n          widgetW = widgetW / aspect;\n          widgetH = widgetH / aspect;\n        }\n      } else if (w < h) {\n        // portrait\n        widgetW = w;\n        widgetH = widgetW / 2;\n        if (config.title.length > 0) {\n          widgetH = widgetW / 1.25;\n        }\n      } else {\n        // square\n        widgetW = w;\n        widgetH = widgetW * 0.5;\n        if (config.title.length > 0) {\n          widgetH = widgetW * 0.75;\n        }\n      }\n      dx = (w - widgetW) / 2;\n      dy = (h - widgetH) / 2;\n      if (config.titlePosition === 'below') {\n        // shift whole thing up to make room for title below\n        dy -= widgetH / 6.4;\n      }\n    }\n\n    // Calculate center point using widget positioning\n    const cx = dx + widgetW / 2;\n    const cy = config.donut ? dy + widgetH / 2 : dy + widgetH / 1.25;\n\n    // Calculate radii using widget width (not canvas width)\n    const outerRadius = config.donut ? widgetW / 2 - widgetW / 30 : widgetW / 2 - widgetW / 10;\n    const gaugeWidthScale = config.gaugeWidthScale || 1.0;\n    const innerRadius = outerRadius - (widgetW / GAUGE_WIDTH_DIVISOR) * gaugeWidthScale;\n\n    return { cx, cy, outerRadius, innerRadius, widgetW, widgetH, dx, dy };\n  }\n\n  /**\n   * Calculate font sizes for different text elements\n   * @param {number} widgetH - Widget height\n   * @param {object} config - Configuration object\n   * @returns {object} Object containing all calculated font sizes\n   * @private\n   */\n  _calculateFontSizes(widgetH, config) {\n    const titleFontSize =\n      widgetH / 8 > config.titleMinFontSize ? widgetH / 10 : config.titleMinFontSize;\n\n    const valueFontSize = config.donut\n      ? widgetH / 6.4 > 16\n        ? widgetH / 5.4\n        : 18\n      : widgetH / 6.5 > config.valueMinFontSize\n        ? widgetH / 6.5\n        : config.valueMinFontSize;\n\n    const labelFontSize = config.donut\n      ? widgetH / 16 > 10\n        ? widgetH / 16\n        : 10\n      : widgetH / 16 > config.labelMinFontSize\n        ? widgetH / 16\n        : config.labelMinFontSize;\n\n    const minMaxLabelFontSize = config.donut\n      ? widgetH / 16 > 10\n        ? widgetH / 16\n        : 10\n      : widgetH / 16 > config.minLabelMinFontSize\n        ? widgetH / 16\n        : config.minLabelMinFontSize;\n\n    return {\n      title: titleFontSize,\n      value: valueFontSize,\n      label: labelFontSize,\n      minMax: minMaxLabelFontSize,\n    };\n  }\n\n  /**\n   * Apply donut rotation to an element if donut mode is enabled\n   * @param {object} element - SVG element to rotate\n   * @param {object} config - Configuration object\n   * @param {number} widgetW - Widget width\n   * @param {number} widgetH - Widget height\n   * @param {number} dx - X offset\n   * @param {number} dy - Y offset\n   * @private\n   */\n  _applyDonutRotation(element, config, widgetW, widgetH, dx, dy, rotationOverride = null) {\n    if (config.donut) {\n      const centerX = widgetW / 2 + dx;\n      const centerY = widgetH / 2 + dy;\n      const rotation = rotationOverride || config.donutStartAngle || 90;\n      element.transform(`rotate(${rotation} ${centerX} ${centerY})`);\n    }\n  }\n\n  /**\n   * Draw text labels\n   * @private\n   */\n  _drawLabels() {\n    const config = this.config;\n\n    // Use consistent geometry calculations\n    const { widgetW, widgetH, dx, dy } = this._calculateGaugeGeometry();\n\n    // Calculate all font sizes\n    const fontSizes = this._calculateFontSizes(widgetH, config);\n\n    // Title - position using legacy-compatible positioning logic\n    if (config.title) {\n      const titleX = dx + widgetW / 2;\n      let titleY;\n      if (config.donut) {\n        titleY = dy + (config.titlePosition === 'below' ? widgetH + 15 : -5);\n      } else {\n        titleY = dy + (config.titlePosition === 'below' ? widgetH * 1.07 : widgetH / 6.4);\n      }\n\n      this.canvas.title = this.renderer.text(titleX, titleY, config.title).attr({\n        'font-family': config.titleFontFamily,\n        'font-size': fontSizes.title,\n        'font-weight': config.titleFontWeight,\n        'text-anchor': 'middle',\n        fill: config.titleFontColor,\n      });\n    }\n\n    // Calculate value position (needed for label positioning even if value is hidden)\n    const valueX = dx + widgetW / 2;\n    const valueY = config.donut\n      ? config.label\n        ? dy + widgetH / 1.85\n        : dy + widgetH / 1.7\n      : dy + widgetH / 1.275;\n\n    // Value - only draw if not hidden\n    if (!config.hideValue) {\n      const displayValue = this._formatValue(config.value);\n\n      this.canvas.value = this.renderer.text(valueX, valueY, displayValue).attr({\n        'font-family': config.valueFontFamily,\n        'font-size': fontSizes.value,\n        'font-weight': 'bold',\n        'text-anchor': 'middle',\n        fill: config.valueFontColor,\n      });\n    }\n\n    // Main label (units like %, km/h, etc.)\n    if (config.label) {\n      const labelY = config.donut ? valueY + fontSizes.label : valueY + fontSizes.value / 2 + 5;\n\n      this.canvas.label = this.renderer.text(valueX, labelY, config.label).attr({\n        'font-family': config.labelFontFamily,\n        'font-size': fontSizes.label,\n        'text-anchor': 'middle',\n        fill: config.labelFontColor,\n      });\n    }\n\n    // Min/Max labels (hidden in donut mode like original)\n    if (config.showMinMax && !config.hideMinMax && !config.donut) {\n      // Use original positioning formula with proper offsets\n      const gaugeWidthScale = config.gaugeWidthScale || 1.0;\n\n      // Use exact original positioning formula\n      // For donut: labelY = valueY + labelFontSize\n      // For regular: labelY = valueY + valueFontSize / 2 + 5\n      let minMaxLabelY;\n      if (config.donut) {\n        minMaxLabelY = valueY + fontSizes.label;\n      } else {\n        // Use original formula exactly as in original JustGage\n        minMaxLabelY = valueY + fontSizes.value / 2 + 5;\n      }\n\n      // Original positioning: based on widget width and scale with offsets\n      const minX = dx + widgetW / 10 + ((widgetW / GAUGE_WIDTH_DIVISOR) * gaugeWidthScale) / 2;\n      const maxX =\n        dx + widgetW - widgetW / 10 - ((widgetW / GAUGE_WIDTH_DIVISOR) * gaugeWidthScale) / 2;\n      const minY = minMaxLabelY;\n      const maxY = minMaxLabelY;\n      // Determine min and max text using utility function\n      const minText = this._formatDisplayText(config.min, config, 'min');\n      const maxText = this._formatDisplayText(config.max, config, 'max');\n\n      if (!config.reverse) {\n        this.canvas.min = this.renderer.text(minX, minY, minText).attr({\n          'font-family': config.labelFontFamily,\n          'font-size': fontSizes.minMax,\n          'text-anchor': 'middle',\n          fill: config.labelFontColor,\n        });\n\n        this.canvas.max = this.renderer.text(maxX, maxY, maxText).attr({\n          'font-family': config.labelFontFamily,\n          'font-size': fontSizes.minMax,\n          'text-anchor': 'middle',\n          fill: config.labelFontColor,\n        });\n      } else {\n        // Reverse positions for reversed gauge\n        this.canvas.min = this.renderer.text(maxX, maxY, minText).attr({\n          'font-family': config.labelFontFamily,\n          'font-size': fontSizes.minMax,\n          'text-anchor': 'middle',\n          fill: config.labelFontColor,\n        });\n\n        this.canvas.max = this.renderer.text(minX, minY, maxText).attr({\n          'font-family': config.labelFontFamily,\n          'font-size': fontSizes.minMax,\n          'text-anchor': 'middle',\n          fill: config.labelFontColor,\n        });\n      }\n    }\n  }\n\n  /**\n   * Draw gauge pointer using original JustGage needle algorithm\n   * @private\n   */\n  _drawPointer() {\n    const config = this.config;\n    const { widgetW, widgetH, dx, dy } = this._calculateGaugeGeometry();\n\n    // Clamp value to min/max for visual representation\n    const clampedValue = this._clampValue(config.value);\n\n    // Calculate reversed value if needed (same as original implementation)\n    let value = clampedValue;\n    if (config.reverse) {\n      value = config.max + config.min - clampedValue;\n    }\n\n    const min = config.min;\n    const max = config.max;\n    const gws = config.gaugeWidthScale;\n    const donut = config.donut;\n\n    // Use original pointer dimension calculations\n    let dlt = (widgetW * 3.5) / 100; // top length\n    let dlb = widgetW / 15; // bottom length\n    let dw = widgetW / 100; // width\n\n    if (config.pointerOptions.toplength != null && config.pointerOptions.toplength !== undefined) {\n      dlt = config.pointerOptions.toplength;\n    }\n    if (\n      config.pointerOptions.bottomlength != null &&\n      config.pointerOptions.bottomlength !== undefined\n    ) {\n      dlb = config.pointerOptions.bottomlength;\n    }\n    if (\n      config.pointerOptions.bottomwidth != null &&\n      config.pointerOptions.bottomwidth !== undefined\n    ) {\n      dw = config.pointerOptions.bottomwidth;\n    }\n\n    let alpha, Ro, Ri, Cy, Xo, Yo, Xi, Yi, Xc, Yc, Xz, Yz, Xa, Ya, Xb, Yb, path;\n\n    if (donut) {\n      alpha = (1 - (2 * (value - min)) / (max - min)) * Math.PI;\n      Ro = widgetW / 2 - widgetW / 30;\n      Ri = Ro - (widgetW / GAUGE_WIDTH_DIVISOR) * gws;\n\n      Cy = widgetH / 2 + dy;\n\n      Xo = widgetW / 2 + dx + Ro * Math.cos(alpha);\n      Yo = widgetH - (widgetH - Cy) - Ro * Math.sin(alpha);\n      Xi = widgetW / 2 + dx + Ri * Math.cos(alpha);\n      Yi = widgetH - (widgetH - Cy) - Ri * Math.sin(alpha);\n\n      Xc = Xo + dlt * Math.cos(alpha);\n      Yc = Yo - dlt * Math.sin(alpha);\n      Xz = Xi - dlb * Math.cos(alpha);\n      Yz = Yi + dlb * Math.sin(alpha);\n\n      Xa = Xz + dw * Math.sin(alpha);\n      Ya = Yz + dw * Math.cos(alpha);\n      Xb = Xz - dw * Math.sin(alpha);\n      Yb = Yz - dw * Math.cos(alpha);\n\n      path = `M${Xa},${Ya} L${Xb},${Yb} L${Xc},${Yc} Z`;\n    } else {\n      alpha = (1 - (value - min) / (max - min)) * Math.PI;\n      Ro = widgetW / 2 - widgetW / 10;\n      Ri = Ro - (widgetW / GAUGE_WIDTH_DIVISOR) * gws;\n\n      Cy = widgetH / 1.25 + dy;\n\n      Xo = widgetW / 2 + dx + Ro * Math.cos(alpha);\n      Yo = widgetH - (widgetH - Cy) - Ro * Math.sin(alpha);\n      Xi = widgetW / 2 + dx + Ri * Math.cos(alpha);\n      Yi = widgetH - (widgetH - Cy) - Ri * Math.sin(alpha);\n\n      Xc = Xo + dlt * Math.cos(alpha);\n      Yc = Yo - dlt * Math.sin(alpha);\n      Xz = Xi - dlb * Math.cos(alpha);\n      Yz = Yi + dlb * Math.sin(alpha);\n\n      Xa = Xz + dw * Math.sin(alpha);\n      Ya = Yz + dw * Math.cos(alpha);\n      Xb = Xz - dw * Math.sin(alpha);\n      Yb = Yz - dw * Math.cos(alpha);\n\n      path = `M${Xa},${Ya} L${Xb},${Yb} L${Xc},${Yc} Z`;\n    }\n\n    // Draw pointer using the generated path\n    this.canvas.pointer = this.renderer.path(path).attr({\n      fill: config.pointerOptions.color || '#000000',\n      stroke: config.pointerOptions.stroke || 'none',\n      'stroke-width': config.pointerOptions.stroke_width || 0,\n      'stroke-linecap': config.pointerOptions.stroke_linecap || 'square',\n    });\n\n    // Apply donut rotation if needed\n    this._applyDonutRotation(\n      this.canvas.pointer,\n      config,\n      widgetW,\n      widgetH,\n      dx,\n      dy,\n      config.donutStartAngle || 90\n    );\n  }\n\n  /**\n   * Draw target line at specified value\n   * @private\n   */\n  _drawTargetLine() {\n    const config = this.config;\n\n    if (config.targetLine == null) {\n      return;\n    }\n\n    const { widgetW, widgetH, dx, dy } = this._calculateGaugeGeometry();\n\n    // Calculate reversed target value if needed (same as original implementation)\n    let targetValue = config.targetLine;\n    if (config.reverse) {\n      targetValue = config.max + config.min - config.targetLine;\n    }\n\n    // Calculate angle based on gauge type (matching SVG renderer logic)\n    let alpha;\n    if (config.donut) {\n      // Donut gauges use different angle calculation with 2x factor\n      alpha = (1 - (2 * (targetValue - config.min)) / (config.max - config.min)) * Math.PI;\n    } else {\n      // Standard gauge angle calculation\n      alpha = (1 - (targetValue - config.min) / (config.max - config.min)) * Math.PI;\n    }\n\n    let Ro = widgetW / 2 - widgetW / 10;\n    let Ri = Ro - (widgetW / GAUGE_WIDTH_DIVISOR) * config.gaugeWidthScale;\n    let Cx, Cy, Xo, Yo, Xi, Yi;\n\n    if (config.donut) {\n      Ro = widgetW / 2 - widgetW / 30;\n      Ri = Ro - (widgetW / GAUGE_WIDTH_DIVISOR) * config.gaugeWidthScale;\n\n      Cx = widgetW / 2 + dx;\n      Cy = widgetH / 2 + dy;\n\n      Xo = Cx + Ro * Math.cos(alpha);\n      Yo = Cy - Ro * Math.sin(alpha);\n      Xi = Cx + Ri * Math.cos(alpha);\n      Yi = Cy - Ri * Math.sin(alpha);\n    } else {\n      Cx = widgetW / 2 + dx;\n      Cy = widgetH / 1.25 + dy;\n\n      Xo = Cx + Ro * Math.cos(alpha);\n      Yo = Cy - Ro * Math.sin(alpha);\n      Xi = Cx + Ri * Math.cos(alpha);\n      Yi = Cy - Ri * Math.sin(alpha);\n    }\n\n    // Create path from inner to outer radius (like original)\n    const pathData = `M ${Xi} ${Yi} L ${Xo} ${Yo}`;\n\n    this.canvas.targetLine = this.renderer.path(pathData).attr({\n      stroke: config.targetLineColor,\n      'stroke-width': config.targetLineWidth,\n    });\n\n    // Apply donut rotation if needed (same as gauge elements)\n    this._applyDonutRotation(this.canvas.targetLine, config, widgetW, widgetH, dx, dy);\n  }\n\n  /**\n   * Get level color based on value\n   * @private\n   */\n  _getLevelColor(value) {\n    const config = this.config;\n    const range = config.max - config.min;\n    const clampedValue = this._clampValue(value);\n    const ratio = (clampedValue - config.min) / range;\n\n    // Use the same getColor function as the original JustGage\n    return getColor(\n      clampedValue,\n      ratio,\n      config.levelColors,\n      config.noGradient,\n      config.customSectors\n    );\n  }\n\n  /**\n   * Format text for display based on configuration\n   * @param {number} value - The numeric value to format\n   * @param {object} config - Configuration object\n   * @param {string} textType - Type of text ('min', 'max', 'value')\n   * @returns {string} Formatted text\n   * @private\n   */\n  _formatDisplayText(value, config, textType = 'value') {\n    // Handle custom text overrides first\n    if (textType === 'min' && config.minTxt) {\n      return config.minTxt;\n    }\n    if (textType === 'max' && config.maxTxt) {\n      return config.maxTxt;\n    }\n\n    // Apply formatting based on configuration\n    if (config.humanFriendly) {\n      return (\n        humanFriendlyNumber(value, config.humanFriendlyDecimal) +\n        (textType === 'value' ? config.symbol : '')\n      );\n    } else if (config.formatNumber) {\n      const formatted = formatNumber(\n        textType === 'value' ? (value * 1).toFixed(config.decimals) : value\n      );\n      return formatted + (textType === 'value' ? config.symbol : '');\n    } else if (textType === 'value' && config.displayRemaining) {\n      return ((config.max - value) * 1).toFixed(config.decimals) + config.symbol;\n    } else {\n      const formatted = textType === 'value' ? (value * 1).toFixed(config.decimals) : value;\n      return formatted + (textType === 'value' ? config.symbol : '');\n    }\n  }\n\n  /**\n   * Clamp value to min/max range for visual representation\n   * @private\n   * @param {number} value - Value to clamp\n   * @returns {number} Clamped value within min/max boundaries\n   */\n  _clampValue(value) {\n    const config = this.config;\n    return Math.max(config.min, Math.min(config.max, value));\n  }\n\n  /**\n   * Format value for display\n   * @private\n   */\n  _formatValue(value) {\n    const config = this.config;\n\n    if (config.textRenderer && typeof config.textRenderer === 'function') {\n      const renderedValue = config.textRenderer(value);\n      if (renderedValue !== false) {\n        return renderedValue;\n      }\n    }\n\n    return this._formatDisplayText(value, config, 'value');\n  }\n\n  /**\n   * Refresh gauge with new values\n   * @param {number} val - New value\n   * @param {number} [max] - New maximum value\n   * @param {number} [min] - New minimum value\n   * @param {string} [label] - New label\n   */\n  refresh(val, max, min, label) {\n    if (!isNumber(val)) {\n      throw new Error('JustGage: refresh() requires a numeric value');\n    }\n\n    // Store current value to animate from\n    const currentValue = this._getCurrentDisplayValue();\n\n    // Store original value for display formatting (before clamping)\n    const originalVal = val;\n\n    // Update label if provided\n    if (label !== null && label !== undefined) {\n      this.config.label = label;\n      if (this.canvas.label) {\n        this.canvas.label.attr({ text: this.config.label });\n      }\n    }\n\n    // Update minimum value if provided\n    if (isNumber(min)) {\n      this.config.min = min;\n\n      // Update min text display\n      if (this.canvas.min) {\n        const minText = this._formatDisplayText(this.config.min, this.config, 'min');\n        this.canvas.min.attr({ text: minText });\n      }\n    }\n\n    // Update maximum value if provided\n    if (isNumber(max)) {\n      this.config.max = max;\n\n      // Update max text display\n      if (this.canvas.max) {\n        const maxText = this._formatDisplayText(this.config.max, this.config, 'max');\n        this.canvas.max.attr({ text: maxText });\n      }\n    }\n\n    // Store the actual value (no clamping) - visual clamping happens in _drawLevel and _drawPointer\n    val = val * 1;\n\n    // Format display value using original logic\n    let displayVal = originalVal; // Use original input value for display\n\n    if (this.config.textRenderer && this.config.textRenderer(displayVal) !== false) {\n      displayVal = this.config.textRenderer(displayVal);\n    } else if (this.config.humanFriendly) {\n      displayVal =\n        humanFriendlyNumber(displayVal, this.config.humanFriendlyDecimal) + this.config.symbol;\n    } else if (this.config.formatNumber) {\n      displayVal =\n        formatNumber((displayVal * 1).toFixed(this.config.decimals)) + this.config.symbol;\n    } else if (this.config.displayRemaining) {\n      displayVal =\n        ((this.config.max - displayVal) * 1).toFixed(this.config.decimals) + this.config.symbol;\n    } else {\n      displayVal = (displayVal * 1).toFixed(this.config.decimals) + this.config.symbol;\n    }\n\n    this.config.value = val * 1;\n\n    // Update value display\n    if (!this.config.counter && !this.config.hideValue && this.canvas.value) {\n      this.canvas.value.attr({ text: displayVal });\n    }\n\n    // Animate level change with proper animation using new animator\n    this.animator.animate({\n      fromValue: currentValue,\n      toValue: this.config.value,\n      duration: this.config.refreshAnimationTime,\n      easing: this.config.refreshAnimationType,\n      onUpdate: newValue => {\n        this._drawLevel(newValue);\n        if (this.config.pointer) {\n          this._updatePointer(newValue);\n        }\n      },\n      onCounterUpdate: this.config.counter\n        ? newValue => {\n            this._updateCounterText(newValue);\n          }\n        : null,\n      onComplete: () => {\n        // Call animation end callback if provided\n        if (this.config.onAnimationEnd && typeof this.config.onAnimationEnd === 'function') {\n          this.config.onAnimationEnd.call(this);\n        }\n      },\n    });\n  }\n\n  /**\n   * Update gauge appearance options\n   * @param {object|string} options - Options object or option name\n   * @param {any} [val] - Option value (if options is string)\n   */\n  update(options, val) {\n    if (typeof options === 'string') {\n      this._updateProperty(options, val);\n    } else if (options && typeof options === 'object') {\n      for (const [option, value] of Object.entries(options)) {\n        this._updateProperty(option, value);\n      }\n    }\n  }\n\n  /**\n   * Update a single property\n   * @param {string} option - Property name\n   * @param {any} val - Property value\n   * @private\n   */\n  _updateProperty(option, val) {\n    switch (option) {\n      case 'valueFontColor':\n        if (!isHexColor(val)) {\n          console.warn('JustGage: valueFontColor must be a valid hex color'); // eslint-disable-line no-console\n          return;\n        }\n        this.config.valueFontColor = val;\n        if (this.canvas.value) {\n          this.canvas.value.attr({ fill: val });\n        }\n        break;\n\n      case 'labelFontColor':\n        if (!isHexColor(val)) {\n          console.warn('JustGage: labelFontColor must be a valid hex color'); // eslint-disable-line no-console\n          return;\n        }\n        this.config.labelFontColor = val;\n        // Update all label elements\n        if (this.canvas.min) {\n          this.canvas.min.attr({ fill: val });\n        }\n        if (this.canvas.max) {\n          this.canvas.max.attr({ fill: val });\n        }\n        if (this.canvas.label) {\n          this.canvas.label.attr({ fill: val });\n        }\n        break;\n\n      case 'gaugeColor':\n        this.config.gaugeColor = val;\n        if (this.canvas.background) {\n          this.canvas.background.attr({ fill: val });\n        }\n        break;\n\n      case 'levelColors':\n        this.config.levelColors = val;\n        // Redraw level with new colors\n        if (this.canvas.level) {\n          this.canvas.level.remove();\n          this._drawLevel();\n        }\n        break;\n\n      case 'targetLine':\n        this.config.targetLine = val;\n        // Remove existing target line\n        if (this.canvas.targetLine) {\n          this.canvas.targetLine.remove();\n          this.canvas.targetLine = null;\n        }\n        // Draw new target line if value is set\n        if (val !== null && val !== undefined) {\n          this._drawTargetLine();\n        }\n        break;\n\n      case 'targetLineColor':\n        this.config.targetLineColor = val;\n        if (this.canvas.targetLine) {\n          this.canvas.targetLine.attr({ stroke: val });\n        }\n        break;\n\n      case 'targetLineWidth':\n        this.config.targetLineWidth = val;\n        if (this.canvas.targetLine) {\n          this.canvas.targetLine.attr({ 'stroke-width': val });\n        }\n        break;\n\n      case 'symbol':\n        this.config.symbol = val;\n        if (this.canvas.value) {\n          const displayValue = this._formatValue(this.config.value);\n          this.canvas.value.attr({ text: displayValue });\n        }\n        break;\n\n      case 'decimals':\n        this.config.decimals = val;\n        if (this.canvas.value) {\n          const displayValue = this._formatValue(this.config.value);\n          this.canvas.value.attr({ text: displayValue });\n        }\n        break;\n\n      case 'title':\n        this.config.title = val;\n        if (this.canvas.title) {\n          this.canvas.title.attr({ text: val || '' });\n        } else if (val) {\n          // Create title if it doesn't exist and value is provided\n          const geometry = this._calculateGaugeGeometry();\n          const fontSizes = this._calculateFontSizes(geometry.widgetH, this.config);\n\n          // Use title positioning from geometry calculations\n          const { titleX, titleY } = geometry;\n\n          this.canvas.title = this.renderer.text(titleX, titleY, val).attr({\n            'font-family': this.config.titleFontFamily,\n            'font-size': fontSizes.title,\n            'font-weight': this.config.titleFontWeight,\n            'text-anchor': 'middle',\n            fill: this.config.titleFontColor,\n          });\n        }\n        break;\n\n      case 'titleFontColor':\n        if (!isHexColor(val)) {\n          console.warn('JustGage: titleFontColor must be a valid hex color'); // eslint-disable-line no-console\n          return;\n        }\n        this.config.titleFontColor = val;\n        if (this.canvas.title) {\n          this.canvas.title.attr({ fill: val });\n        }\n        break;\n\n      case 'showSectorColors':\n        this.config.showSectorColors = val;\n        // Clear existing sectors or level\n        if (this.canvas.sectors) {\n          this.canvas.sectors.forEach(sector => sector.remove());\n          this.canvas.sectors = null;\n        }\n        if (this.canvas.level) {\n          this.canvas.level.remove();\n          this.canvas.level = null;\n        }\n        // Redraw based on new setting\n        if (val) {\n          this._drawSectorColors();\n        } else {\n          this._drawLevel();\n        }\n        break;\n\n      case 'customSectors':\n        this.config.customSectors = val;\n        // If showSectorColors is enabled, redraw sectors\n        if (this.config.showSectorColors) {\n          this._drawSectorColors();\n        } else if (this.canvas.level) {\n          // Redraw regular level with potentially new sector-based colors\n          this.canvas.level.remove();\n          this.canvas.level = null;\n          this._drawLevel();\n        }\n        break;\n\n      default:\n        console.warn(`JustGage: \"${option}\" is not a supported update setting`); // eslint-disable-line no-console\n    }\n  }\n\n  /**\n   * Destroy the gauge and clean up resources\n   */\n  destroy() {\n    // Cancel any running animations\n    if (this.animator) {\n      this.animator.cancel();\n    }\n\n    // Clean up SVG renderer\n    if (this.renderer) {\n      this.renderer.remove();\n    }\n\n    // Clear container\n    if (this.node?.parentNode) {\n      this.node.innerHTML = '';\n    }\n\n    // Clear references\n    this.node = null;\n    this.config = null;\n    this.renderer = null;\n    this.animator = null;\n    this.canvas = null;\n  }\n\n  /**\n   * Get current gauge value\n   * @returns {number} Current value\n   */\n  getValue() {\n    return this.config.value;\n  }\n\n  /**\n   * Get current configuration\n   * @returns {object} Current configuration\n   */\n  getConfig() {\n    return { ...this.config };\n  }\n\n  /**\n   * Initialize shadow effects using SVGRenderer\n   * @private\n   */\n  _initializeShadow() {\n    const config = this.config;\n    const shadowId = 'inner-shadow-' + (config.id || config.classId);\n\n    // Create shadow filter using renderer\n    this.renderer.createShadowFilter(shadowId, {\n      verticalOffset: config.shadowVerticalOffset,\n      size: config.shadowSize,\n      opacity: config.shadowOpacity,\n    });\n\n    // Apply shadow to gauge elements\n    const elementsToShadow = [];\n    if (this.canvas.gauge) elementsToShadow.push(this.canvas.gauge);\n    if (this.canvas.level) elementsToShadow.push(this.canvas.level);\n\n    this.renderer.applyShadowToElements(shadowId, elementsToShadow);\n\n    // Store shadow ID for later use\n    this.shadowId = shadowId;\n  }\n\n  /**\n   * Start initial gauge animation\n   * @private\n   */\n  _startInitialAnimation() {\n    const config = this.config;\n\n    if (config.startAnimationTime <= 0) {\n      // No animation, just draw final state\n      this._drawLevel(config.value);\n      if (config.pointer) {\n        this._drawPointer();\n      }\n      if (config.onAnimationEnd) {\n        config.onAnimationEnd();\n      }\n      return;\n    }\n\n    // Determine starting value based on gauge type:\n    // - Differential gauges start from middle\n    // - Regular gauges start from min\n    // - Reverse changes the direction but uses same starting logic\n    let fromValue;\n    if (config.differential) {\n      fromValue = (config.max + config.min) / 2; // Start from middle for differential\n    } else if (config.reverse) {\n      fromValue = config.max; // Start from max for reverse gauges\n    } else {\n      fromValue = config.min; // Start from min for regular gauges\n    }\n\n    // Start animation from appropriate starting value to target value\n    this.animator.animate({\n      fromValue: fromValue,\n      toValue: config.value,\n      duration: config.startAnimationTime,\n      easing: config.startAnimationType,\n      onUpdate: currentValue => {\n        this._drawLevel(currentValue);\n        if (config.pointer) {\n          this._updatePointer(currentValue);\n        }\n      },\n      onCounterUpdate: config.counter\n        ? currentValue => {\n            this._updateCounterText(currentValue);\n          }\n        : null,\n      onComplete: config.onAnimationEnd,\n    });\n  }\n\n  /**\n   * Update pointer position during animation\n   * @private\n   */\n  _updatePointer(value) {\n    if (this.canvas.pointer) {\n      this.canvas.pointer.remove();\n    }\n\n    // Temporarily update config value for pointer calculation\n    const originalValue = this.config.value;\n    this.config.value = value;\n    this._drawPointer();\n    this.config.value = originalValue;\n  }\n\n  /**\n   * Update counter text during animation\n   * @private\n   */\n  _updateCounterText(value) {\n    const config = this.config;\n    let displayValue = value;\n\n    // Apply text formatting\n    if (config.textRenderer && config.textRenderer(displayValue) !== false) {\n      displayValue = config.textRenderer(displayValue);\n    } else {\n      displayValue = this._formatDisplayText(value, config, 'value');\n    }\n\n    if (this.canvas.value && !this.config.hideValue) {\n      this.canvas.value.attr({ text: displayValue });\n    }\n  }\n\n  /**\n   * Get current display value for animation starting point\n   * @private\n   */\n  _getCurrentDisplayValue() {\n    // Try to extract current value from level path or use stored value\n    return this.config.value || this.config.min;\n  }\n}\n", "{\"version\":\"2.0.1\"}", "/**\n * JustGage - Modern SVG Gauges\n * Entry point for the library\n *\n */\n\nimport { JustGage } from './core/JustGage.js';\nimport pkgJson from '../package.json' with { type: 'json' };\n\nJustGage.VERSION = pkgJson.version;\n\n// Export the main class\nexport { JustGage };\n\n// Default export for easier importing\nexport default JustGage;\n"],
  "mappings": "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",
  "names": []
}
